// Code generated by go generate; DO NOT EDIT.
package internal

import (
	"encoding/json"
	"fmt"
	fhirpath "github.com/DAMEDIC/fhir-toolbox-go/fhirpath"
	"github.com/DAMEDIC/fhir-toolbox-go/model"
	"github.com/DAMEDIC/fhir-toolbox-go/model/gen/r4"
	"github.com/DAMEDIC/fhir-toolbox-go/model/gen/r4b"
	"github.com/DAMEDIC/fhir-toolbox-go/model/gen/r5"
	"github.com/DAMEDIC/fhir-toolbox-go/utils/ptr"
)

// buildR4Parameters builds R4 Parameters response
func buildR4Parameters[R model.Release](result evalResult, inputs evalInputs) r4.Parameters {
	var release R
	out := r4.Parameters{}

	// Build result parameters
	for _, res := range result.results {
		resultParam := r4.ParametersParameter{
			Name: r4.String{Value: ptr.To("result")},
			Part: makePartsR4(res.values),
		}

		if res.contextPath != "" {
			resultParam.Value = r4.String{Value: &res.contextPath}
		}

		// Add trace parts
		for _, te := range res.traces {
			tname := "trace"
			tr := r4.ParametersParameter{
				Name:  r4.String{Value: &tname},
				Value: r4.String{Value: &te.name},
				Part:  makePartsR4(te.values),
			}
			resultParam.Part = append(resultParam.Part, tr)
		}

		out.Parameter = append(out.Parameter, resultParam)
	}

	// Build parameters part
	evalLabel := fmt.Sprintf("fhir-toolbox-go (%s)", release)
	paramsPart := r4.ParametersParameter{
		Name: r4.String{Value: ptr.To("parameters")},
		Part: []r4.ParametersParameter{
			{Name: r4.String{Value: ptr.To("evaluator")}, Value: r4.String{Value: &evalLabel}},
			{Name: r4.String{Value: ptr.To("expression")}, Value: r4.String{Value: &inputs.expression}},
		},
	}

	if inputs.context != "" {
		paramsPart.Part = append(paramsPart.Part, r4.ParametersParameter{
			Name:  r4.String{Value: ptr.To("context")},
			Value: r4.String{Value: &inputs.context},
		})
	}

	// Add resource parameter - use json-value extension to support cross-release resources
	resourceJSON, err := json.Marshal(inputs.resource)
	if err == nil {
		resourceJSONStr := string(resourceJSON)
		paramsPart.Part = append(paramsPart.Part, r4.ParametersParameter{
			Name: r4.String{Value: ptr.To("resource")},
			Extension: []r4.Extension{{
				Url:   "http://fhir.forms-lab.com/StructureDefinition/json-value",
				Value: r4.String{Value: &resourceJSONStr},
			}},
		})
	}

	// Add variables if present
	if len(inputs.variables) > 0 {
		varsParam := r4.ParametersParameter{Name: r4.String{Value: ptr.To("variables")}}
		for name, value := range inputs.variables {
			if valueStr, ok, _ := value.ToString(false); ok {
				vs := string(valueStr)
				varsParam.Part = append(varsParam.Part, r4.ParametersParameter{
					Name:  r4.String{Value: &name},
					Value: r4.String{Value: &vs},
				})
			}
		}
		paramsPart.Part = append(paramsPart.Part, varsParam)
	}

	out.Parameter = append(out.Parameter, paramsPart)
	return out
}

// makePartsR4 converts FHIRPath collection to R4 parameter parts
func makePartsR4(values fhirpath.Collection) []r4.ParametersParameter {
	var parts []r4.ParametersParameter

	for _, v := range values {
		tname := typeNameOf(v)

		// Try to use value[x] first for primitive types
		pv, ok := v.(r4.ParametersParameterValue)
		if ok {
			parts = append(parts, r4.ParametersParameter{Name: r4.String{Value: &tname}, Value: pv})
			continue
		}

		// For everything else (resources, complex types, etc.), use json-value extension
		jsonBytes, err := json.Marshal(v)
		if err == nil {
			jsonStr := string(jsonBytes)
			parts = append(parts, r4.ParametersParameter{
				Name: r4.String{Value: &tname},
				Extension: []r4.Extension{{
					Url:   "http://fhir.forms-lab.com/StructureDefinition/json-value",
					Value: r4.String{Value: &jsonStr},
				}},
			})
		}
	}
	return parts
}

// opErrR4 creates R4 OperationOutcome for errors
func opErrR4(severity, code, diagnostics string) r4.OperationOutcome {
	return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
		Severity: r4.Code{Value: &severity},
		Code:     r4.Code{Value: &code},
		Details:  nil,
		Diagnostics: func() *r4.String {
			if diagnostics == "" {
				return nil
			}
			return &r4.String{Value: &diagnostics}
		}(),
	}}}
}

// buildR4BParameters builds R4B Parameters response
func buildR4BParameters[R model.Release](result evalResult, inputs evalInputs) r4b.Parameters {
	var release R
	out := r4b.Parameters{}

	// Build result parameters
	for _, res := range result.results {
		resultParam := r4b.ParametersParameter{
			Name: r4b.String{Value: ptr.To("result")},
			Part: makePartsR4B(res.values),
		}

		if res.contextPath != "" {
			resultParam.Value = r4b.String{Value: &res.contextPath}
		}

		// Add trace parts
		for _, te := range res.traces {
			tname := "trace"
			tr := r4b.ParametersParameter{
				Name:  r4b.String{Value: &tname},
				Value: r4b.String{Value: &te.name},
				Part:  makePartsR4B(te.values),
			}
			resultParam.Part = append(resultParam.Part, tr)
		}

		out.Parameter = append(out.Parameter, resultParam)
	}

	// Build parameters part
	evalLabel := fmt.Sprintf("fhir-toolbox-go (%s)", release)
	paramsPart := r4b.ParametersParameter{
		Name: r4b.String{Value: ptr.To("parameters")},
		Part: []r4b.ParametersParameter{
			{Name: r4b.String{Value: ptr.To("evaluator")}, Value: r4b.String{Value: &evalLabel}},
			{Name: r4b.String{Value: ptr.To("expression")}, Value: r4b.String{Value: &inputs.expression}},
		},
	}

	if inputs.context != "" {
		paramsPart.Part = append(paramsPart.Part, r4b.ParametersParameter{
			Name:  r4b.String{Value: ptr.To("context")},
			Value: r4b.String{Value: &inputs.context},
		})
	}

	// Add resource parameter - use json-value extension to support cross-release resources
	resourceJSON, err := json.Marshal(inputs.resource)
	if err == nil {
		resourceJSONStr := string(resourceJSON)
		paramsPart.Part = append(paramsPart.Part, r4b.ParametersParameter{
			Name: r4b.String{Value: ptr.To("resource")},
			Extension: []r4b.Extension{{
				Url:   "http://fhir.forms-lab.com/StructureDefinition/json-value",
				Value: r4b.String{Value: &resourceJSONStr},
			}},
		})
	}

	// Add variables if present
	if len(inputs.variables) > 0 {
		varsParam := r4b.ParametersParameter{Name: r4b.String{Value: ptr.To("variables")}}
		for name, value := range inputs.variables {
			if valueStr, ok, _ := value.ToString(false); ok {
				vs := string(valueStr)
				varsParam.Part = append(varsParam.Part, r4b.ParametersParameter{
					Name:  r4b.String{Value: &name},
					Value: r4b.String{Value: &vs},
				})
			}
		}
		paramsPart.Part = append(paramsPart.Part, varsParam)
	}

	out.Parameter = append(out.Parameter, paramsPart)
	return out
}

// makePartsR4B converts FHIRPath collection to R4B parameter parts
func makePartsR4B(values fhirpath.Collection) []r4b.ParametersParameter {
	var parts []r4b.ParametersParameter

	for _, v := range values {
		tname := typeNameOf(v)

		// Try to use value[x] first for primitive types
		pv, ok := v.(r4b.ParametersParameterValue)
		if ok {
			parts = append(parts, r4b.ParametersParameter{Name: r4b.String{Value: &tname}, Value: pv})
			continue
		}

		// For everything else (resources, complex types, etc.), use json-value extension
		jsonBytes, err := json.Marshal(v)
		if err == nil {
			jsonStr := string(jsonBytes)
			parts = append(parts, r4b.ParametersParameter{
				Name: r4b.String{Value: &tname},
				Extension: []r4b.Extension{{
					Url:   "http://fhir.forms-lab.com/StructureDefinition/json-value",
					Value: r4b.String{Value: &jsonStr},
				}},
			})
		}
	}
	return parts
}

// opErrR4B creates R4B OperationOutcome for errors
func opErrR4B(severity, code, diagnostics string) r4b.OperationOutcome {
	return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
		Severity: r4b.Code{Value: &severity},
		Code:     r4b.Code{Value: &code},
		Details:  nil,
		Diagnostics: func() *r4b.String {
			if diagnostics == "" {
				return nil
			}
			return &r4b.String{Value: &diagnostics}
		}(),
	}}}
}

// buildR5Parameters builds R5 Parameters response
func buildR5Parameters[R model.Release](result evalResult, inputs evalInputs) r5.Parameters {
	var release R
	out := r5.Parameters{}

	// Build result parameters
	for _, res := range result.results {
		resultParam := r5.ParametersParameter{
			Name: r5.String{Value: ptr.To("result")},
			Part: makePartsR5(res.values),
		}

		if res.contextPath != "" {
			resultParam.Value = r5.String{Value: &res.contextPath}
		}

		// Add trace parts
		for _, te := range res.traces {
			tname := "trace"
			tr := r5.ParametersParameter{
				Name:  r5.String{Value: &tname},
				Value: r5.String{Value: &te.name},
				Part:  makePartsR5(te.values),
			}
			resultParam.Part = append(resultParam.Part, tr)
		}

		out.Parameter = append(out.Parameter, resultParam)
	}

	// Build parameters part
	evalLabel := fmt.Sprintf("fhir-toolbox-go (%s)", release)
	paramsPart := r5.ParametersParameter{
		Name: r5.String{Value: ptr.To("parameters")},
		Part: []r5.ParametersParameter{
			{Name: r5.String{Value: ptr.To("evaluator")}, Value: r5.String{Value: &evalLabel}},
			{Name: r5.String{Value: ptr.To("expression")}, Value: r5.String{Value: &inputs.expression}},
		},
	}

	if inputs.context != "" {
		paramsPart.Part = append(paramsPart.Part, r5.ParametersParameter{
			Name:  r5.String{Value: ptr.To("context")},
			Value: r5.String{Value: &inputs.context},
		})
	}

	// Add resource parameter - use json-value extension to support cross-release resources
	resourceJSON, err := json.Marshal(inputs.resource)
	if err == nil {
		resourceJSONStr := string(resourceJSON)
		paramsPart.Part = append(paramsPart.Part, r5.ParametersParameter{
			Name: r5.String{Value: ptr.To("resource")},
			Extension: []r5.Extension{{
				Url:   "http://fhir.forms-lab.com/StructureDefinition/json-value",
				Value: r5.String{Value: &resourceJSONStr},
			}},
		})
	}

	// Add variables if present
	if len(inputs.variables) > 0 {
		varsParam := r5.ParametersParameter{Name: r5.String{Value: ptr.To("variables")}}
		for name, value := range inputs.variables {
			if valueStr, ok, _ := value.ToString(false); ok {
				vs := string(valueStr)
				varsParam.Part = append(varsParam.Part, r5.ParametersParameter{
					Name:  r5.String{Value: &name},
					Value: r5.String{Value: &vs},
				})
			}
		}
		paramsPart.Part = append(paramsPart.Part, varsParam)
	}

	out.Parameter = append(out.Parameter, paramsPart)
	return out
}

// makePartsR5 converts FHIRPath collection to R5 parameter parts
func makePartsR5(values fhirpath.Collection) []r5.ParametersParameter {
	var parts []r5.ParametersParameter

	for _, v := range values {
		tname := typeNameOf(v)

		// Try to use value[x] first for primitive types
		pv, ok := v.(r5.ParametersParameterValue)
		if ok {
			parts = append(parts, r5.ParametersParameter{Name: r5.String{Value: &tname}, Value: pv})
			continue
		}

		// For everything else (resources, complex types, etc.), use json-value extension
		jsonBytes, err := json.Marshal(v)
		if err == nil {
			jsonStr := string(jsonBytes)
			parts = append(parts, r5.ParametersParameter{
				Name: r5.String{Value: &tname},
				Extension: []r5.Extension{{
					Url:   "http://fhir.forms-lab.com/StructureDefinition/json-value",
					Value: r5.String{Value: &jsonStr},
				}},
			})
		}
	}
	return parts
}

// opErrR5 creates R5 OperationOutcome for errors
func opErrR5(severity, code, diagnostics string) r5.OperationOutcome {
	return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
		Severity: r5.Code{Value: &severity},
		Code:     r5.Code{Value: &code},
		Details:  nil,
		Diagnostics: func() *r5.String {
			if diagnostics == "" {
				return nil
			}
			return &r5.String{Value: &diagnostics}
		}(),
	}}}
}
