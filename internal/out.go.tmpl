// Code generated by go generate; DO NOT EDIT.
package internal

import (
	"encoding/json"
	"fmt"
	fhirpath "github.com/damedic/fhir-toolbox-go/fhirpath"
	"github.com/damedic/fhir-toolbox-go/model"
	"github.com/damedic/fhir-toolbox-go/model/gen/r4"
	"github.com/damedic/fhir-toolbox-go/model/gen/r4b"
	"github.com/damedic/fhir-toolbox-go/model/gen/r5"
	"github.com/damedic/fhir-toolbox-go/utils/ptr"
)
{{range .Releases}}

// build{{.Release}}Parameters builds {{.Release}} Parameters response
func build{{.Release}}Parameters[R model.Release](result evalResult, inputs evalInputs) {{.PackageName}}.Parameters {
	var release R
	out := {{.PackageName}}.Parameters{}

	// Build result parameters
	for _, res := range result.results {
		resultParam := {{.PackageName}}.ParametersParameter{
			Name: {{.PackageName}}.String{Value: ptr.To("result")},
			Part: makeParts{{.Release}}(res.values),
		}

		if res.contextPath != "" {
			resultParam.Value = {{.PackageName}}.String{Value: &res.contextPath}
		}

		// Add trace parts
		for _, te := range res.traces {
			tname := "trace"
			tr := {{.PackageName}}.ParametersParameter{
				Name:  {{.PackageName}}.String{Value: &tname},
				Value: {{.PackageName}}.String{Value: &te.name},
				Part:  makeParts{{.Release}}(te.values),
			}
			resultParam.Part = append(resultParam.Part, tr)
		}

		out.Parameter = append(out.Parameter, resultParam)
	}

	// Build parameters part
	evalLabel := fmt.Sprintf("fhir-toolbox-go (%s)", release)
	paramsPart := {{.PackageName}}.ParametersParameter{
		Name: {{.PackageName}}.String{Value: ptr.To("parameters")},
		Part: []{{.PackageName}}.ParametersParameter{
			{Name: {{.PackageName}}.String{Value: ptr.To("evaluator")}, Value: {{.PackageName}}.String{Value: &evalLabel}},
			{Name: {{.PackageName}}.String{Value: ptr.To("expression")}, Value: {{.PackageName}}.String{Value: &inputs.expression}},
		},
	}

	if inputs.context != "" {
		paramsPart.Part = append(paramsPart.Part, {{.PackageName}}.ParametersParameter{
			Name:  {{.PackageName}}.String{Value: ptr.To("context")},
			Value: {{.PackageName}}.String{Value: &inputs.context},
		})
	}

	// Add resource parameter - use json-value extension to support cross-release resources
	resourceJSON, err := json.Marshal(inputs.resource)
	if err == nil {
		resourceJSONStr := string(resourceJSON)
		paramsPart.Part = append(paramsPart.Part, {{.PackageName}}.ParametersParameter{
			Name: {{.PackageName}}.String{Value: ptr.To("resource")},
			Extension: []{{.PackageName}}.Extension{{ "{{" }}
				Url:   "http://fhir.forms-lab.com/StructureDefinition/json-value",
				Value: {{.PackageName}}.String{Value: &resourceJSONStr},
			{{ "}}" }},
		})
	}

	// Add variables if present
	if len(inputs.variables) > 0 {
		varsParam := {{.PackageName}}.ParametersParameter{Name: {{.PackageName}}.String{Value: ptr.To("variables")}}
		for name, value := range inputs.variables {
			if valueStr, ok, _ := value.ToString(false); ok {
				vs := string(valueStr)
				varsParam.Part = append(varsParam.Part, {{.PackageName}}.ParametersParameter{
					Name:  {{.PackageName}}.String{Value: &name},
					Value: {{.PackageName}}.String{Value: &vs},
				})
			}
		}
		paramsPart.Part = append(paramsPart.Part, varsParam)
	}

	out.Parameter = append(out.Parameter, paramsPart)
	return out
}

// makeParts{{.Release}} converts FHIRPath collection to {{.Release}} parameter parts
func makeParts{{.Release}}(values fhirpath.Collection) []{{.PackageName}}.ParametersParameter {
	var parts []{{.PackageName}}.ParametersParameter

	for _, v := range values {
		tname := typeNameOf(v)

		// Try to use value[x] first for primitive types
		pv, ok := v.({{.PackageName}}.ParametersParameterValue)
		if ok {
			parts = append(parts, {{.PackageName}}.ParametersParameter{Name: {{.PackageName}}.String{Value: &tname}, Value: pv})
			continue
		}

		// For everything else (resources, complex types, etc.), use json-value extension
		jsonBytes, err := json.Marshal(v)
		if err == nil {
			jsonStr := string(jsonBytes)
			parts = append(parts, {{.PackageName}}.ParametersParameter{
				Name: {{.PackageName}}.String{Value: &tname},
				Extension: []{{.PackageName}}.Extension{{ "{{" }}
					Url:   "http://fhir.forms-lab.com/StructureDefinition/json-value",
					Value: {{.PackageName}}.String{Value: &jsonStr},
				{{ "}}" }},
			})
		}
	}
	return parts
}

// opErr{{.Release}} creates {{.Release}} OperationOutcome for errors
func opErr{{.Release}}(severity, code, diagnostics string) {{.PackageName}}.OperationOutcome {
	return {{.PackageName}}.OperationOutcome{Issue: []{{.PackageName}}.OperationOutcomeIssue{{ "{{" }}
		Severity: {{.PackageName}}.Code{Value: &severity},
		Code:     {{.PackageName}}.Code{Value: &code},
		Details:  nil,
		Diagnostics: func() *{{.PackageName}}.String {
			if diagnostics == "" {
				return nil
			}
			return &{{.PackageName}}.String{Value: &diagnostics}
		}(),
	{{ "}}" }}}
}
{{end}}
